# -*- coding: utf-8 -*-
"""Grid_Search_SA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L0fQzab73eSLm3K5zuto3MxnzdXmQUdc
"""

!pip install ortools

import pandas as pd
import numpy as np
from scipy.spatial.distance import cdist
import matplotlib.pyplot as plt
import time
from ortools.constraint_solver import pywrapcp, routing_enums_pb2
import itertools
from tqdm import tqdm

df_centroids = pd.read_csv("/content/centroids_clusters_with_region.csv")
all_centroids = df_centroids[["X", "Y"]].values
coords_with_depot = np.vstack([[0, 0], all_centroids])

distance_matrix = cdist(coords_with_depot, coords_with_depot)

def solve_tsp_closed(coords):
    dist_mat = cdist(coords, coords).tolist()
    n = len(coords)
    depot = 0

    manager = pywrapcp.RoutingIndexManager(n, 1, depot)
    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_idx, to_idx):
        return int(dist_mat[manager.IndexToNode(from_idx)][manager.IndexToNode(to_idx)] * 1000)

    transit_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_index)

    search_params = pywrapcp.DefaultRoutingSearchParameters()
    search_params.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    search_params.local_search_metaheuristic = routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH
    search_params.time_limit.seconds = 75

    solution = routing.SolveWithParameters(search_params)

    if solution:
        index = routing.Start(0)
        route = []
        while not routing.IsEnd(index):
            route.append(manager.IndexToNode(index))
            index = solution.Value(routing.NextVar(index))
        route.append(route[0])
        total_cost = sum(dist_mat[route[i]][route[i+1]] for i in range(len(route)-1))
        return route, total_cost
    else:
        return None, None

def fitness(tour, dist_matrix):
    return sum(dist_matrix[tour[i], tour[i+1]] for i in range(len(tour)-1)) + dist_matrix[tour[-1], tour[0]]

def generate_greedy_initial_route(dist_matrix):
    n = len(dist_matrix)
    unvisited = set(range(1, n))
    route = [0]
    current = 0
    while unvisited:
        next_node = min(unvisited, key=lambda x: dist_matrix[current][x])
        route.append(next_node)
        unvisited.remove(next_node)
        current = next_node
    return route

def two_opt(route, dist_matrix, max_iter=1000):
    best = route
    improved = True
    while improved and max_iter > 0:
        improved = False
        for i in range(1, len(route) - 2):
            for j in range(i+1, len(route) -1):
                if j - i == 1:
                    continue
                new_route = best[:i] + best[i:j][::-1] + best[j:]
                if fitness(new_route, dist_matrix) < fitness(best, dist_matrix):
                    best = new_route
                    improved = True
        max_iter -= 1
    return best

def get_neighbor(route):
    new_route = route[:]
    i, j = sorted(np.random.choice(range(1, len(route)), size=2, replace=False))
    move_type = np.random.choice(["reverse", "swap", "insert"])
    if move_type == "reverse":
        new_route[i:j+1] = reversed(new_route[i:j+1])
    elif move_type == "swap":
        new_route[i], new_route[j] = new_route[j], new_route[i]
    elif move_type == "insert":
        node = new_route.pop(i)
        new_route.insert(j, node)
    return new_route

def simulated_annealing(distance_matrix, initial_route,
    initial_temp=500, cooling_rate=0.995, stopping_temp=1e-4,
    max_iter=3000, interval_log=50, n_iter_2opt=20, local_max_iter=30):
    current_route = initial_route[:]
    current_cost = fitness(current_route, distance_matrix)
    best_route = current_route[:]
    best_cost = current_cost
    temperature = initial_temp
    cost_log = []
    iteration = 0
    while temperature > stopping_temp and iteration < max_iter:
        neighbor_route = get_neighbor(current_route)
        if iteration % n_iter_2opt == 0:
            neighbor_route = two_opt(neighbor_route, distance_matrix, max_iter=local_max_iter)
        neighbor_cost = fitness(neighbor_route, distance_matrix)
        if neighbor_cost < current_cost or np.random.rand() < np.exp((current_cost - neighbor_cost) / temperature):
            current_route = neighbor_route
            current_cost = neighbor_cost
            if current_cost < best_cost:
                best_route = current_route[:]
                best_cost = current_cost
        cost_log.append(current_cost)
        if iteration % interval_log == 0:
            print(f"Iterasi {iteration:4d} | Cost: {current_cost:.2f} | Best: {best_cost:.2f} | Suhu: {temperature:.2f}")
        temperature *= cooling_rate
        iteration += 1
    print(f"Final Iterasi {iteration} | Best Cost: {best_cost:.2f}")
    return best_route, best_cost, cost_log

initial_temps = [100, 200, 500]
cooling_rates = [0.97, 0.99, 0.995, 0.999]
max_iters = [1000, 2000, 3000]
n_iter_2opts = [5, 10, 20]

param_combinations = list(itertools.product(initial_temps, cooling_rates, max_iters, n_iter_2opts))

grid_results = []

for (initial_temp, cooling_rate, max_iter, n_iter_2opt) in tqdm(param_combinations, desc="Grid Search"):
    initial_route = generate_greedy_initial_route(distance_matrix)
    start_time = time.time()

    try:
        best_route, best_cost, cost_log = simulated_annealing(
            distance_matrix, initial_route,
            initial_temp=initial_temp,
            cooling_rate=cooling_rate,
            stopping_temp=1e-4,
            max_iter=max_iter,
            n_iter_2opt=n_iter_2opt,
            local_max_iter=30
        )
    except:
        best_cost = None

    duration = time.time() - start_time

    grid_results.append({
        "Initial Temp": initial_temp,
        "Cooling Rate": cooling_rate,
        "Max Iter": max_iter,
        "2-opt Interval": n_iter_2opt,
        "Best Cost": f"{best_cost:.2f}" if best_cost else "Failed",
        "Duration (s)": f"{duration:.2f}"
    })

# ===================================================
# Buat DataFrame hasil grid search
# ===================================================
grid_df = pd.DataFrame(grid_results)
display(grid_df)

# ===================================================
# Simpan ke Excel
# ===================================================
output_path = "grid_search_SA_results.xlsx"
grid_df.to_excel(output_path, index=False)
print(f"âœ… File hasil grid search disimpan sebagai: {output_path}")

num_runs = 10
all_best_costs = []
all_best_routes = []
all_cost_logs = []
all_durations = []

for run in range(num_runs):
    initial_route = generate_greedy_initial_route(distance_matrix)
    start_time = time.time()
    best_route, best_cost, cost_log = simulated_annealing(distance_matrix, initial_route)
    duration = time.time() - start_time
    all_best_costs.append(best_cost)
    all_best_routes.append(best_route)
    all_cost_logs.append(cost_log)
    all_durations.append(duration)

# === 6. Buat dataframe hasil
results_df = pd.DataFrame({
    "Run": [f"Run {i+1}" for i in range(num_runs)],
    "Best Cost": [f"{c:.2f}" for c in all_best_costs],
    "Durasi (detik)": [f"{t:.2f}" for t in all_durations]
})
from IPython.display import display
display(results_df)

best_run_index = np.argmin(all_best_costs)
best_run_log = all_cost_logs[best_run_index]
best_cost_progress = np.minimum.accumulate(best_run_log)

plt.figure(figsize=(10, 5))
plt.plot(best_cost_progress)
plt.title(f"Perkembangan Best Cost (Run {best_run_index+1})")
plt.xlabel("Iterasi")
plt.ylabel("Best Cost (Cumulative Minimum)")
plt.grid(True)
plt.tight_layout()
plt.show()

# === 9. Plot all run convergence
plt.figure(figsize=(12, 6))
for i, log in enumerate(all_cost_logs):
    progress = np.minimum.accumulate(log)
    plt.plot(progress, label=f"Run {i+1}")
plt.xlabel("Iterasi")
plt.ylabel("Best Cost")
plt.title("Konvergensi Best Cost (10 Run Simulated Annealing)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

best_route = all_best_routes[best_run_index]
best_cost = all_best_costs[best_run_index]
plt.figure(figsize=(12, 8))

# DataFrame koordinat + region
df_coords = pd.DataFrame(coords_with_depot, columns=["X", "Y"])
df_coords["Region"] = "Depot"
df_coords.loc[1:, "Region"] = df_centroids["Region"].values  # centroid mulai index 1

# Scatter titik centroid per inner
for region in ["inner_1", "inner_2", "inner_3"]:
    region_points = df_coords[df_coords["Region"] == region]
    plt.scatter(region_points["X"], region_points["Y"], s=60, label=region, alpha=0.7)

# Scatter depot
plt.scatter(df_coords.iloc[0]["X"], df_coords.iloc[0]["Y"], s=100, c='red', edgecolor='black', label="Depot")

# Plot jalur rute UAV
for i in range(len(best_route) - 1):
    start = coords_with_depot[best_route[i]]
    end = coords_with_depot[best_route[i+1]]
    plt.plot([start[0], end[0]], [start[1], end[1]], 'k-', linewidth=1.5)
start = coords_with_depot[best_route[-1]]
end = coords_with_depot[best_route[0]]
plt.plot([start[0], end[0]], [start[1], end[1]], 'k-', linewidth=1.5)

# Label urutan traversal
for i, idx in enumerate(best_route):
    point = coords_with_depot[idx]
    label = "Depot" if idx == 0 else f"C{idx}"
    plt.annotate(label, (point[0] + 1, point[1] + 1), fontsize=8)

plt.title(f"Optimized UAV Route with Simulated Annealing\nBest Cost: {best_cost:.2f} meters (Run {best_run_index+1})")
plt.xlabel("X (meters)")
plt.ylabel("Y (meters)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

